# FIFO compaction style

FIFO 컴팩션은 컴팩션 대상을 선택하는데 가장 편리한 구현 방식이다. 이벤트 로그 데이터 등을 저장하는데 매우 적은 오버헤드로 데이터베이스를 관리 할 수 있다. 주기적으로 오래된 데이터를 삭제할 수 있는 쉬운 방법이 되므로, 기본적으로 TTL을 기반으로 한 컴팩션이라고 표현할 수 있다.

FIFO 컴팩션에서 모든 파일은 레벨 0에 존재한다. 전체 사이즈가 설정된 max 사이즈를 초과하는 경우, 가장 오래된 파일부터 차례대로 삭제한다. 즉, write amplification이 항상 1이라는 의미이다. 

현재는 `CompactionRange()` 함수를 통해서 필요할 때마다 컴팩션을 작동시키고, 오래된 테이블 파일들을 삭제한다. FIFO 컴팩션을 사용할때는 함수를 통해 전달된 인자를 모두 무시한다.

항상 오래된 파일을 삭제하기만 하고 key-value를 다시 디스크에 기록하는 일이 없기 때문에, 컴팩션 필터 또한 적용하지 않는다. 

위와 같은 이유로 사용자에게 사전 고지 없이 오래된 데이터 들이 삭제될 수 있으므로, FIFO 컴팩션을 사용할때는 주의해야 한다.



## Compaction

FIFO컴팩션은 모든 파일이 L0에 존재하기 때문에, 컴팩션이 끝난 후에도 많은 파일들이 L0에 남아있을 수 있다. 그로 인해서 사용자 쿼리를 처리할 때, 최악의 경우에는 L0의 모든 파일을 찾아봐야 할 수도 있고, 블룸 필터를 사용하더라도 모든 대상을 찾지 못할 수 있다. false positive 확률은 보통 1%이므로, 1000개의 L0 파일이 있을 경우 평균적으로 10번의 false positive가 발생할 수 있고, 최악의 경우에는 10번의 추가 I/O를 발생시킨다. 최악의 경우를 줄이기 위해서 더 많은 블룸필터 비트를 사용하면 되지만, 메모리가 추가로 필요한 단점이 있고, 블룸필터 검색에 사용되는 CPU 오버헤드가 수용불가능할 수 있다.

위와 같은 최악의 상황을 피하기 위해서, 일종의 가벼운 컴팩션을 발생시킬 수도 있다. 아래에서 설명할 추가적인 방법은 write I/O를 두배로 증가시킬 가능성이 높지만, L0 파일의 갯수를 많이 줄여준다. 이러한 I/O와 성능의 trade off는 사용자에 따라서 적절한 대안이 될 수 있다.

5.5버전과 함께 새롭게 추가된 이 기능은 `CompactionOptionsFIFO.allow_compaction = true`를 통해서 활성화 할 수 있다. 최소 `level0_file_num_compaction_trigger` 파일을 선택하여 함께 컴팩션을 수행한다.

항상 가장 최신의 파일들을 선택하고 `options.write_buffer_size`를 초과하지 않는선에서 컴팩션을 수행한다. 일반적인 워크로드에서 항상 `level0_file_num_comapction_trigger` 갯수만큼의 가장 최신 파일을 플러쉬 하게 될 것이다.

예를 들어, `level0_file_num_compaction_trigger = 8`의 옵션을 사용하고, memtable에서 플러쉬 되는 파일의 크기가 100MB라고 가정하면, 100MB짜리 8개의 새로운 테이블 파일이 생성 될때마다 800MB의 하나의 파일로 컴팩션 한다. 이를 통해서 결국에 L0에 800MB짜리 파일들의 묶음이 생성되게 된다. 

FIFO 컴팩션은 따로 오래된 파일을 계속 삭제하므로, 서브 컴팩션에 의해서 생성된 대형 파일들을 삭제 하다 보면, 서브 컴팩션을 사용하지 않는 경우보다 결과적으로 더 적은 공간을 사용하게 된다.



## FIFO Compaction with TTL

RocksDB 5.7부터는 FIFO compaction with TTL 기능이 추가되었다. 

이전까지는 오로지 전체 파일 사이즈만을 컴팩션 기준으로 삼았다. 예를 들어서, 가장 오래된 파일 순서대로 데이터베이스 사이즈를 측정했을 때 `compaction_options_fifo.max_table_files_size`를 초과한 경우, 해당 threshold 미만으로 낮아 질 때까지 파일들을 삭제 했다. 

새로운 옵션인 `compaction_options_fifo.ttl`을 사용할 경우 TTL이 초과된 SST 파일들에 대해서만 삭제를 수행할 수 있다. 이 옵션을 통해서 데이터베이스 사이즈를 통해 컴팩션을 트리거 하지 않고, TTL 시간을 통해서 컴팩션을 트리거 할 수 있다.

제한 사항:

- 현재는 `max_open_files`가 -1로 설정된 상태의 Block-based 테이블에서만 동작한다.
- FIFO with TTL을 사용하더라도, 일단 컴팩션이 트리거 된 이후에는, 설정된 max size 미만으로 데이터베이스 크기가 줄어들기 전까지는 TTL과 무관하게 오래된 파일을 삭제할 수 있다. 